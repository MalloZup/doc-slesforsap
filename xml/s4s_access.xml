<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="cha.s4s.access">
 <title>Restricting and Granting Access to the Machine</title>

 <para>
  This chapter presents information about restricting access to the system
  using firewalling and encryption and gives information about connecting to
  the system remotely.
 </para>

 <sect1 xml:id="sec.s4s.configure.firewall">
  <title>Configuring &susefirewall;</title>

  <para>
   By default, the installation workflow of &sles4sap; enables
   &susefirewall;. The firewall needs to
   be manually configured to allow network access for the following:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     SAP application
    </para>
   </listitem>
   <listitem>
    <para>
     Database (see the documentation of your database vendor; for &hana;, see
     <xref linkend="sec.s4s.configure.firewall-hana"/>)
    </para>
   </listitem>
  </itemizedlist>
  <para>
   Additionally, open the ports <literal>1128</literal> (TCP) and
   <literal>1129</literal> (UDP).
  </para>

  <para>
   SAP applications require many open ports and port ranges in the firewall.
   The exact numbers depend on the selected instance. For more information,
   see the documentation provided to you by SAP.
  </para>
 </sect1>

 <sect1 xml:id="sec.s4s.configure.firewall-hana">
  <title>Configuring <systemitem>HANA-Firewall</systemitem></title>

  <para>
   To simplify setting up a firewall for &hana;, install the package
   <systemitem>HANA-Firewall</systemitem>.
   Whereas standard &susefirewall; allows only three zones (internal, DMZ, and
   external), <systemitem>HANA-Firewall</systemitem> enables you to configure
   more zones to accommodate all running &hana; instances.
  </para>
  <para>
   <systemitem>HANA-Firewall</systemitem> works by adding rule sets to your
   existing &susefirewall; configuration.
  </para>
  <para>
   <systemitem>HANA-Firewall</systemitem> consists of the following parts:
  </para>
  <itemizedlist>
   <listitem>
    <formalpara>
     <title>&yast; Module <guimenu>SAP HANA Firewall</guimenu></title>
     <para>
      Allows configuring, applying, and reverting firewall rules for &hana;
      from a graphical user interface.
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>Command-Line Utility <systemitem>hana-firewall</systemitem></title>
     <para>
      Allows applying and reverting the configured firewall rules for &hana;.
     </para>
    </formalpara>
    <para>
     If you prefer, you can configure the rule sets using the
     configuration file at <filename>/etc/sysconfig/hana-firewall</filename>
     instead of using &yast;.
    </para>
   </listitem>
   <listitem>
    <formalpara>
     <title>Service <systemitem>hana-firewall</systemitem></title>
     <para>
      Ensures that configured firewall rules for &hana; are kept.
     </para>
    </formalpara>
   </listitem>
  </itemizedlist>

  <important>
   <title>Multi-Tenant Databases</title>
   <para>
    For multi-tenant &hana; databases, determining the port numbers that
    need to be opened is not yet possible automatically.
    If you are working with a multi-tenant &hana; database system, before you
    use &yast;, run a script on the command line to create a new
    service definition:
   </para>
<screen>&prompt.root;<command>cd /etc/hana-firewall.d</command>
&prompt.root;<command>./create_new_service</command></screen>
   <para>
    You need to switch to the directory
    <filename>/etc/hana-firewall.d</filename>,
    otherwise the rule file for the new service will be created in a place
    where it cannot be used.
   </para>
   <para>
    The script will ask several questions: Importantly, it will ask for
    TCP and UDP port ranges that need to be opened.
   </para>
  </important>

  <procedure>
   <title>Using <systemitem>HANA-Firewall</systemitem></title>
   <step>
    <para>
     Make sure the &hana; databases for which you want to configure the
     firewall are correctly installed.
    </para>
   </step>
   <step>
    <para>
     To open the appropriate &yast; module, select
     <menuchoice><guimenu>Applications</guimenu><guimenu>YaST</guimenu>
     </menuchoice>, <menuchoice><guimenu>Security and Users</guimenu>
     <guimenu>SAP HANA Firewall</guimenu></menuchoice>.
    </para>
   </step>
   <step>
    <para>
     When you open this &yast; module, it will create a configuration proposal
     based on the number of installed &hana; instances.
    </para>
   </step>
   <step>
    <para>
     In the module, set the <guimenu>Number of network interfaces in this
     HANA setup</guimenu>.
    </para>
   </step>
   <step>
    <para>
     Choose an <guimenu>Interface number</guimenu> and its
     corresponding network interface name (for example,
     <guimenu>eth0</guimenu>).
    </para>
   </step>
   <step>
    <para>
     Allow network services by selecting them in the list box on the left and
     clicking <guimenu>Add</guimenu>. Remove services by selecting them in the
     list box on the right and clicking <guimenu>Remove</guimenu>.
    </para>
    <para>
     To add services other than the preconfigured ones, add them using the
     following notation:
    </para>
<screen><replaceable>SERVICE_NAME</replaceable>:<replaceable>CIDR_NOTATION</replaceable></screen>
    <para>
     For more information about the CIDR notation, see
     <link xlink:href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing"/>.
     To find out which services are available on your system, use
     <command>getent services</command>.
    </para>
   </step>
   <step>
    <!--
     This step is called "Next" because actually this is a part of a wizard
     of which just a single step is taken out, apparently. There is no later
     button that needs to be clicked.
     - sknorr, 2016-02-18
    -->
    <para>
     When you are done, click <guimenu>Next</guimenu>.
    </para>
    <para>
     The firewall rules from <systemitem>HANA-Firewall</systemitem> will now
     be compiled and applied. Finally, the service
     <systemitem>hana-firewall</systemitem> will be restarted.
    </para>
   </step>
   <step>
    <para>
     Finally, check whether <systemitem>HANA-Firewall</systemitem> was enabled
     correctly:
    </para>
<screen>&prompt.root;<command>hana-firewall status</command>
HANA firewall is active. Everything is OK.
</screen>
    <tip>
     <title>Checking Which Firewall Rules Are Enabled</title>
     <para>
      Gaining an overview of which firewall rules are enabled in the current
      configuration of the script is possible using the command line:
     </para>
<screen>&prompt.root;<command>hana-firewall dry-run</command></screen>
    </tip>
   </step>
  </procedure>
  <para>
   For more information, see the man page of <command>hana_firewall</command>.
  </para>
 </sect1>

 <sect1 xml:id="sec.s4s.configure.cryptctl">
  <title>Encrypting Directories Using <command>cryptctl</command></title>
  <para>
   <command>cryptctl</command> consists of two components:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     A client is a machine that has one or more encrypted partitions but does
     not have the necessary key to decrypt those partitions. Clients can be,
     for example, cloud or otherwise hosted machines.
    </para>
   </listitem>
   <listitem>
    <para>
     The server holds encryption keys that can be requested by clients to
     unlock encrypted partitions. Since the server holds encryption keys, it
     should be under your direct control and managed only by trusted personnel.
    </para>
   </listitem>
  </itemizedlist>
  <para>
   To handle encryption, <command>cryptctl</command> uses LUKS with
   aes-xts-256 encryption and 512-bit keys.
  </para>
  <figure xml:id="fig.s4s.cryptctl-retrieve">
   <title>Key Retrieval with <command>cryptctl</command></title>
   <mediaobject>
    <imageobject role="html">
     <imagedata fileref="cryptctl-keyretrieval.png" format="PNG"/>
    </imageobject>
    <imageobject role="fo">
     <imagedata fileref="cryptctl-keyretrieval.svg" width="80%" format="SVG"/>
    </imageobject>
    <textobject role="description">
     <phrase>The client asks the server for the disk decryption key, the server
     responds</phrase>
    </textobject>
   </mediaobject>
  </figure>
  <warning>
   <title>Encrypt Connection Between Client and Server</title>
   <para>
    <command>cryptctl</command> clients and servers exchange encryption keys.
    <command>cryptctl</command> itself does not set up transport security,
    however. To enable transport security between both machines,
    use a VPN, for example.
   </para>
   <para>
    For more information about setting up a VPN, see
    <citetitle>&secguide;, Part <quote>Network Security</quote>, Chapter
    <quote>Configuring a VPN Server</quote> </citetitle> (&docaddress;).
   </para>
  </warning>
  <note>
   <title>Install <command>cryptctl</command></title>
   <para>
    Before continuing, make sure the package <package>cryptctl</package> is
    installed.
   </para>
  </note>
  <sect2 xml:id="sec.s4s.configure.cryptctl-server">
   <title>Setting Up a <command>cryptctl</command> Server</title>
   <para>
    Before you can define machine as a <command>cryptctl</command> client,
    you need to set up a machine as a <command>cryptctl</command> server.
   </para>
   <procedure>
    <step>
     <para>
      As <systemitem class="username">root</systemitem>, run:
     </para>
     <screen>&prompt.root;<command>cryptctl init-server</command></screen>
    </step>
    <step>
     <para>
      Answer each of the following prompts and press <keycap function="enter"/>
      after every answer. If there is a default answer, it is shown in square
      brackets at the end of the prompt.
     </para>
     <substeps>
      <step>
       <para>
        Choose a password with at least 10 characters and confirm it. This
        password assumes the role of a master password, able to unlock all
        partitions that are registered on the server.
       </para>
      </step>
      <step>
       <para>
        Specify the path to a PEM-encoded TLS certificate or certificate chain
        file or leave the field empty to create a self-signed certificate. If
        you specify a path, use an absolute path.
       </para>
      </step>
      <step>
       <para>
        If you want the server to be identified by a host name other than the
        default shown, specify a host name. <command>cryptctl</command> will
        then generate certificates which include the host name.
       </para>
      </step>
      <step>
       <para>
        Specify the IP address that belongs to the network interface that you
        want to listen on for decryption requests from the clients, then set
        a port number.
       </para>
       <remark>
        Would IPv6 addresses work? - sknorr, 2016-11-07
       </remark>
       <para>
        If you use <systemitem class="ipaddress">0.0.0.0</systemitem> as the
        IP address (the default), <command>cryptctl</command> will listen on
        all network interfaces for client requests.
       </para>
      </step>
      <step>
       <para>
        Set a directory for the keys needed to decrypt partitions on the
        clients.
       </para>
      </step>
      <step>
       <para>
        Finally, configure an SMTP server for e-mail notifications for
        encryption and decryption requests or leave the prompt empty to skip
        setting up e-mail notifications.
       </para>
       <remark>
        Can I set a password here? Or do I basically need an own little SMTP
        server locally which forward notifications elsewhere? - sknorr,
        2016-11-03
       </remark>
      </step>
      <step>
       <para>
        When asked whether to start the <command>cryptctl</command> server,
        enter <literal>y</literal>.
       </para>
      </step>
     </substeps>
    </step>
    <step>
     <para>
      To check the status of the service
      <systemitem class="daemon">cryptctl-server</systemitem>, use:
     </para>
     <screen>&prompt.root;<command>systemctl status cryptctl-server</command></screen>
    </step>
   </procedure>
   <para>
    To reconfigure the server later, do either of the following:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Run the command <command>cryptctl init-server</command> again.
      <command>cryptctl</command> will then propose the existing settings as
      the defaults, so that you only need to the specify values that you want
      to change.
     </para>
    </listitem>
    <listitem>
     <para>
      Make changes directly in the configuration file
      <filename>/etc/sysconfig/cryptctl-server</filename>.
     </para>
     <para>
      However, to avoid issues, do not change the settings
      <option>AUTH_PASSWORD_HASH</option> and
      <option>AUTH_PASSWORD_SALT</option> manually. The values of these
      options needs to be calculated correctly.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>
  <sect2 xml:id="sec.s4s.configure.cryptctl-client">
   <title>Setting Up a <command>cryptctl</command> Client</title>
   <para>
    The following interactive setup of <command>cryptctl</command> is
    currently the only setup method.
   </para>
   <para>
    Make sure the following preconditions are fulfilled:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      A <command>cryptctl</command> server is available over the network.
     </para>
    </listitem>
    <listitem>
     <para>
      There is a directory to encrypt.
     </para>
    </listitem>
    <listitem>
     <para>
      The client machine has an empty partition available that is large
      enough to fit the directory to encrypt.
     </para>
     <remark>
      Is it possible to use cryptctl with LVM? - sknorr, 2016-11-07
     </remark>
     <remark>
      Is the partition always reformatted to Btrfs? (Btrfs has a 256 MiB
      minimum size.) - sknorr, 2016-11-07
     </remark>
    </listitem>
    <listitem>
     <para>
      To enable encryption between the client and the server, the certificate
      (<filename>*.crt</filename> file) generated on the server is
      available locally on the client.
     </para>
     <!-- Actually, the wizard just stops because of a curl error. - sknorr,
     2016-11-03 -->
     <!-- <para>
      Failing to provide the server certificate means that client and server
      can only communicate over an insecure connection.
     </para> -->
    </listitem>
   </itemizedlist>
   <procedure>
    <step>
     <para>
      As <systemitem class="username">root</systemitem>, run:
     </para>
     <screen>&prompt.root;<command>cryptctl encrypt</command></screen>
    </step>
    <step>
     <para>
      Answer each of the following prompts and press <keycap function="enter"/>
      after every answer. If there is a default answer, it is shown in square
      brackets at the end of the prompt.
     </para>
     <substeps>
      <step>
       <para>
        Specify the host name and port to connect to on the
        <command>cryptctl</command> server.
       </para>
      </step>
      <step>
       <para>
        Specify the path to the server certificate (the
        <filename>*.crt</filename> file). Specify an absolute
        path.
       </para>
      </step>
      <step>
       <para>
        Enter the encryption password that you specified when setting up the
        server.
       </para>
      </step>
      <step>
       <para>
        Specify the path to the directory to encrypt. Specify the path to the
        empty partition that will contain the encrypted content of the
        directory.
       </para>
      </step>
      <step>
       <para>
        Specify the number of machines that are allowed to decrypt the
        partition simultaneously.
       </para>
       <para>
        Then specify the timeout in seconds before additional machines are
        allowed to decrypt the partition after the last vital sign was
        received from the client or clients.
       </para>
       <para>
        When a machine unexpectedly stops working and then reboots, it needs to
        be able to unlock its partitions again. That means, this timeout
        should be set to a time slightly shorter than the reboot time of the
        client.
       </para>
       <para>
        If the time is set too long, the machine will not be able to decrypt
        encrypted partitions automatically and must then have them decrypted
        manually. If the timeout is set too short, machines with a copy of
        the encrypted partition have an increased chance of unlocking the
        partition first.
       </para>
      </step>
     </substeps>
    </step>
    <step>
     <para>
      <command>cryptctl</command> will now encrypt the specified directory to
      the previously empty partition and then mount the newly encrypted
      partition.
     </para>
     <para>
      Before creating the encrypted partition,
      <command>cryptctl</command> moves the unencrypted content of the
      original directory to a location prefixed with
      <literal>cryptctl-moved-</literal>. Note the directory name.
     </para>
    </step>
    <step>
     <para>
      To check that the directory is indeed mounted correctly, use:
     </para>
     <screen>
&prompt.user;<command>lsblk -o NAME,MOUNTPOINT,UUID</command>
NAME                        MOUNTPOINT          UUID
[...]
sdc
└─sdc1                                          <replaceable>PARTITION_UUID</replaceable>
  └─cryptctl-unlocked-sdc1  /secret-partition   <replaceable>UNLOCKED_UUID</replaceable>
      </screen>
     <para>
      <command>cryptctl</command> identifies the encrypted partition by its
      UUID. In the previous example, that is the UUID displayed next to
      <literal>sdc1</literal>.
     </para>
     <para>
      On the server, you can check whether the directory was decrypted using
      <command>cryptctl</command>:
     </para>
     <screen>
&prompt.root;<command>cryptctl list-keys</command>
2016/10/10 10:00:00 ReloadDB: successfully loaded database of 1 records
Total: 1 records (date and time are in zone EDT)
Used By      When                  UUID  Max.Users  Num.Users  Mount Point
<replaceable>IP_ADDRESS</replaceable>   2016-10-10 10:00:00   <replaceable>UUID</replaceable>  1          1          /secret-partition
     </screen>
     <para>
      The UUID shown is that of the partition. This means you can
     </para>
    </step>
    <step>
     <para>
      After verifying that the encrypted partition works, delete the
      unencrypted content, for example, using <command>rm</command>. For more
      safety, overwrite the content of the files before deleting them, for
      example, using <command>shred -u</command>.
     </para>
     <important>
      <title><command>shred</command> Does Not Guarantee That Data Is Completely Erased</title>
      <para>
       Depending on the type of storage media, using
       <command>shred</command> is not a guarantee that all data is
       completely removed. In particular, SSDs usually employ wear leveling
       strategies that render <command>shred</command> ineffective.
      </para>
     </important>
    </step>
   </procedure>
   <para>
    The configuration for the client-server connection is stored in
    <filename>/etc/sysconfig/cryptctl-client</filename> and can be edited
    manually.
   </para>
   <para>
    The server stores an encryption key for the client partition in
    <filename>/var/lib/cryptctl/keydb/<replaceable>PARTITION_UUID</replaceable></filename>.
   </para>
  </sect2>
  <sect2 xml:id="sec.s4s.configure.cryptctl-status">
   <title>Checking Partition Unlock Status Using Server-side Commands</title>
   <para>
    When a <command>cryptctl</command> client is active, it will send a
    <quote>heartbeat</quote> to the <command>cryptctl</command> server every
    ten seconds. If the server does not receive a heartbeat from the client
    for the length of the timeout configured during the client setup, the
    server will assume that the client is offline and allow another client to
    connect (or allow the same client to reconnect after a reboot).
   </para>
   <para>
    To see the usage status of all keys, use:
   </para>
   <screen>
&prompt.root;<command>cryptctl list-keys</command>
   </screen>
   <para>
    The information under <literal>Num. Users</literal> shows whether the key
    is currently in use. To see more detail on a single key, use:
   </para>
   <screen>
&prompt.root;<command>cryptctl show-key <replaceable>UUID</replaceable></command>
   </screen>
   <para>
    This command will show information about mount point, mount options,
    usage options, the last retrieval of the key and the last three
    heartbeats from clients.
   </para>
   <para>
    Additionally, you can use <command>journalctl</command> to find logs of
    when keys were retrieved.
   </para>
  </sect2>
  <sect2 xml:id="sec.s4s.configure.cryptctl-unlock">
   <title>Unlocking Encrypted Partitions Manually</title>
   <para>
    There are two ways of unlocking a partition manually, both of which are run
    on a client:
   </para>
   <itemizedlist>
    <listitem>
     <formalpara>
      <title>Online Unlocking</title>
      <para>
       This method can be used when there is a network connection between
       client and server but the client could not unlock the partition
       automatically when booting. This method will unlock all encrypted
       partitions on a machine.
      </para>
     </formalpara>
     <para>
      To use it, run <command>cryptctl online-unlock</command>. Be prepared to
      enter the password specified when setting up the server.
     </para>
    </listitem>
    <listitem>
     <formalpara>
      <title>Offline Unlocking</title>
      <para>
       This method can be used when a client cannot or must not be brought
       online to communicate with its server. The encryption key from the
       server must still be available. This method is meant as a last resort
       only and can only unlock a single partition at a time.
      </para>
     </formalpara>
     <para>
      To use it, run <command>cryptctl offline-unlock</command>. The
      server's key file for the requisite partition
      (<filename>/var/lib/cryptctl/keydb/<replaceable>PARTITION_UUID</replaceable></filename>)
      needs to be available on the client.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>
  <sect2 xml:id="sec.s4s.configure.cryptctl-lock">
   <title>Maintenance Downtime Procedure</title>
   <para>
    To ensure that partitions cannot be decrypted during a maintenance
    downtime, turn off the client and disable the
    <command>cryptctl</command> server. You can do so by either:
   </para>
   <remark>
    What happens when the client can't find a server? Will it try to
    re-encrypt? Apparently not... (testing) - sknorr, 2016-11-07
   </remark>
   <itemizedlist>
    <listitem>
     <para>
      Stopping the service
      <systemitem class="daemon">cryptctl-server</systemitem>:
     </para>
     <screen>
&prompt.root;<command>systemctl stop cryptctl-server</command>
     </screen>
    </listitem>
    <listitem>
     <para>
      Unplugging the <command>cryptctl</command> server from the network.
     </para>
    </listitem>
   </itemizedlist>
   <!-- What about: maintenance personnel makes copy of client, and then the
   client is DoS'ed? In that case, you could boot a fake client without
   issue, it seems..? - sknorr, 2016-11-07 -->
  </sect2>
 </sect1>

 <sect1 xml:id="sec.s4s.configure.rdp">
  <title>Connecting via RDP</title>
  <para>
   If you installed &s4sa; with the RDP option activated or if you installed
   from a &kiwi; image, RDP is enabled on the machine via the service
   <systemitem class="daemon">xrdp</systemitem>. Alternatively, you can enable
   RDP later as described at the end of this section.
  </para>
  <para>
   You can connect using any software that supports RDP, such as:
  </para>
  <itemizedlist>
   <listitem>
    <formalpara>
     <title>Linux:</title>
     <para>
      Vinagre (available in &sled;/&slea; &we; and &opensuse;) or
      Remmina (available in &opensuse;)
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>Windows:</title>
     <para>
      Remote Desktop Connection
     </para>
    </formalpara>
   </listitem>
  </itemizedlist>
  <important>
   <title>Connection Parameters</title>
   <para>
    Make sure to set up the connection with the following parameters:
   </para>
   <itemizedlist>
    <listitem>
     <formalpara>
      <title>Port:</title>
      <para>
       3389
      </para>
     </formalpara>
    </listitem>
    <listitem>
     <formalpara>
      <title>Color Depth:</title>
      <para>
       16-bit or 24-bit only
      </para>
     </formalpara>
    </listitem>
   </itemizedlist>
  </important>

  <procedure xml:id="pro.s4s.enable-rdp">
   <title>Setting Up RDP</title>
   <para>
    If you have not set up an RDP connection during the installation, you can
    also do so later using the following instructions.
   </para>
   <step>
    <para>
     First, create an exception for the firewall. Start by creating a file that
     sets up the port that needs to be opened for RDP.
    </para>
    <para>
     As <systemitem class="username">root</systemitem>, create a new file
     under <filename>/etc/sysconfig/SuSEfirewall2.d/services/</filename> with
     the name <filename>xrdp</filename> and the following content:
    </para>
    <screen>
## Name: Remote Desktop Protocol
TCP="3389"
    </screen>
   </step>
   <step>
    <para>
     Open the file <filename>/etc/sysconfig/SuSEfirewall2</filename> and
     change the lines for the settings
     <option>FW_CONFIGURATIONS_EXT</option>,
     <option>FW_CONFIGURATIONS_DMZ</option>, and
     <option>FW_CONFIGURATIONS_INT</option> to include
     <literal>xrdp</literal>. If there are no other services enabled, the
     respective lines should read:
    </para>
    <screen>
FW_CONFIGURATIONS_EXT="xrdp"
FW_CONFIGURATIONS_DMZ="xrdp"
FW_CONFIGURATIONS_INT="xrdp"
    </screen>
    <para>
     If there are other services, separate them within the quotes using a
     space character.
    </para>
   </step>
   <step>
    <para>
     Now set up <systemitem class="daemon">xrdp</systemitem> itself.
    </para>
    <para>
     If the package <package>xrdp</package> is not installed, install it:
    </para>
    <screen>
&prompt.root;<command>zypper install xrdp</command>
    </screen>
   </step>
   <step>
    <para>
     Enable and start the service:
    </para>
    <screen>
&prompt.root;<command>systemctl restart SuSEfirewall2</command>
    </screen>
   </step>
   <step>
    <para>
     Enable and start the service:
    </para>
    <screen>
&prompt.root;<command>systemctl enable xrdp</command>
&prompt.root;<command>systemctl start xrdp</command>
    </screen>
    <para>
     You can now connect to the machine.
    </para>
   </step>
  </procedure>
 </sect1>

</chapter>
